Operator :: enum {
  Halt,
  Assign,
  Add,
  Sub,
  Mul,
  Div,
  BrEq,
  BrNeq,
  BrLt,
  BrGt,
  Jump,
  
  Push,
  Pop,
  
  Call,
  Return,
  ReturnVoid,
}

operator_names: string[];
 
get_operator_names :: () {
  type := #type Operator;
  for field; type.fields {
    operator_names ~= field.name;
  }
}

OperandValue :: union {
  v_float: float64;
  v_int: s64;
  // refers another code.
  v_reference: s64;
}

OperandTag :: enum {
  Reference,
  Integer,
  Float,
  Alloc,
}

Operand :: struct {
  type: int;
  value: OperandValue;
  to_string :: () -> string {
    if type == OperandTag.Integer {
      return $"{value.v_int}";
    } else if type == OperandTag.Reference {
      return $"*{value.v_reference}";
    } 
    return "Invalid Operand";
  }
}

get_value :: (op : Operand, results: Operand[]*) -> Operand {
  if op.type == OperandTag.Reference {
    return (*results)[op.value.v_reference];
  } else {
    return op;
  }
}

TAC :: struct {
  left: Operand;
  right: Operand;
  destination: s64;
  op: s32;
  to_string :: () -> string {
    return $"left: {left}, right: {right}, destination: {destination}, operator: {operator_names[op]}";
  }
}

make_float_operand :: (f: float64) -> Operand {
  value: OperandValue;
  value.v_float = f;
  return {
    OperandTag.Float,
    value
  };
}

make_int_operand :: (i: s64) -> Operand {
  value: OperandValue;
  value.v_int = i;
  return {
    OperandTag.Integer,
    value
  };
}

make_ref_operand :: (dest: s64) -> Operand {
  value: OperandValue;
  value.v_reference = dest;
  return {
    OperandTag.Reference,
    value
  };
}

make_assign :: (value: Operand, destination: s64) -> TAC {
  code: TAC;
  code.left = value;
  code.op = .Assign;
  code.destination = destination;
  return code;
}

make_binary :: (destination: s64, op: int, left: Operand, right: Operand) -> TAC {
  code: TAC;
  code.left = left;
  code.right = right;
  code.destination = destination;
  code.op = op;
  return code;
}

make_nullary :: (op: int) -> TAC {
  code: TAC;
  code.op = op;
  return code;
}

make_unary :: (destination: s64, op: int) -> TAC {
  code: TAC;
  code.op = op;
  code.destination = destination;
  return code;
}

make_push :: (operand: Operand) -> TAC {
  code: TAC;
  code.op = .Push;
  code.left = operand;
  return code;
}

make_pop :: (destination: s64) -> TAC {
  code: TAC;
  code.op = .Pop;
  code.destination = destination;
  return code;
}

make_call :: (address: Operand, return_addr: s64) -> TAC {
  code: TAC;
  code.left = address;
  code.destination = return_addr;
  code.op = .Call;
  return code;
}