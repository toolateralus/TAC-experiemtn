#import core;

#include "opcodes.ela"
#compiler_flags "-O3"

variables: int[string];
functions: TAC[]*[string];

current_destination: s64;

get_destination :: () -> s64 {
  return current_destination++;
}

execute_tac :: (codes: TAC[]*) -> s64[] {
  results := #make(s64[], codes.length + 1);
  ip: s64;

  while ip < codes.length {
    code := (*codes)[ip];
    if code.op == .Halt then break;

    // Control flow
    {
      should_continue := switch code.op {
        .Jump:  {
          ip = code.destination;
          return true;
        }
        .BrEq:  {
          target := get_value(code.left, &results);
          expected := get_value(code.right, &results);
          if target == expected {
            ip = code.destination;
            return true;
          }
          return false;
        }
        .BrNeq: {
          target := get_value(code.left, &results);
          expected := get_value(code.right, &results);
          if target != expected {
            ip = code.destination;
            return true;
          }
          return false;
        }
        .BrLt:  {
          target := get_value(code.left, &results);
          expected := get_value(code.right, &results);
          if target < expected {
            ip = code.destination;
            return true;
          }
          return false;
        }
        .BrGt:  {
          target := get_value(code.left, &results);
          expected := get_value(code.right, &results);
          if target > expected {
            ip = code.destination;
            return true;
          }
          return false;
        }
      }
      
      if should_continue
        then continue;
    }

    // Binary operations
    {
      lvalue: s64 = get_value(code.left, &results);
      rvalue: s64 = get_value(code.right, &results);
      
      switch code.op {
        .Assign: { results[code.destination] = get_value(code.left, &results); }
        .Add: { results[code.destination] = lvalue + rvalue; }
        .Sub: { results[code.destination] = lvalue - rvalue; }
        .Div: { results[code.destination] = lvalue / rvalue; }
        .Mul: { results[code.destination] = lvalue * rvalue; }
      }
    }
    ip++;
  }
  return results;
}

test_while_loop :: () -> TAC[] {
  codes: TAC[];

  /* 
    MOV EAX, 0
  BEGIN_LOOP:
    JLT 100, LOOP_BODY
    HLT
  LOOP_BODY:
    ADD EAX, 1
    JUMP BEGIN_LOOP
   */

  //? [0]
  //* i = 0;
  codes ~= make_assign(make_int_operand(0), 0);

  //? [1]
  //* while i < 100, jump -> 3;
  codes ~= make_binary(3, .BrLt,
    make_ref_operand(0),
    make_int_operand(100)
  );

  //? [2]
  //* End of loop (when i >= 100)
  codes ~= make_nullary(.Halt);

  //? [3]
  //* i += 1
  codes ~= make_binary(0, .Add,
    make_ref_operand(0),
    make_int_operand(1) // add 1 to *0;
  );

  //? [4]
  //* Jump back to the condition check
  codes ~= make_unary(1, .Jump);

  return codes;
}

main :: () {
  get_operator_names();

  codes := test_while_loop();

  results := execute_tac(&codes);

  i : int;
  for result; results {
    println($"result: {i}={result}");
    i++;
  }
}
